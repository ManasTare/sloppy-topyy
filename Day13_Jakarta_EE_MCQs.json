{
  "deck": "Day 13 â€“ Spring Core Annotations & Java-based Configuration",
  "mcqs": [
    { "id": 1, "question": "@Component is used to:", "options": ["Create database tables", "Define Spring-managed bean", "Configure transactions", "Handle HTTP requests"], "correct": 1 },
    { "id": 2, "question": "Which annotation marks business service layer?", "options": ["@Component", "@Service", "@Repository", "@Controller"], "correct": 1 },
    { "id": 3, "question": "@Repository is mainly used for:", "options": ["UI logic", "Business logic", "Data access layer", "Configuration"], "correct": 2 },
    { "id": 4, "question": "Which annotation enables automatic dependency injection?", "options": ["@Bean", "@ComponentScan", "@Autowired", "@Configuration"], "correct": 2 },
    { "id": 5, "question": "Component scanning searches for beans in:", "options": ["Database", "Packages", "XML files", "JSP files"], "correct": 1 },
    { "id": 6, "question": "Default scope of Spring bean is:", "options": ["Prototype", "Request", "Session", "Singleton"], "correct": 3 },
    { "id": 7, "question": "@Scope is used to define:", "options": ["Package name", "Bean lifecycle", "Bean scope", "Bean ID"], "correct": 2 },
    { "id": 8, "question": "Which annotation replaces XML bean configuration?", "options": ["@Service", "@Configuration", "@Controller", "@Repository"], "correct": 1 },
    { "id": 9, "question": "@Bean is used to:", "options": ["Scan packages", "Define bean via method", "Inject dependency", "Set scope"], "correct": 1 },
    { "id": 10, "question": "@ComponentScan is used to:", "options": ["Create beans manually", "Scan packages for components", "Configure database", "Enable AOP"], "correct": 1 },

    { "id": 11, "question": "Which injection is preferred in Spring?", "options": ["Field injection", "Setter injection", "Constructor injection", "No injection"], "correct": 2 },
    { "id": 12, "question": "@Autowired works by:", "options": ["Name matching only", "Type matching primarily", "XML reference only", "ID matching only"], "correct": 1 },
    { "id": 13, "question": "@Qualifier is used to:", "options": ["Enable scanning", "Resolve bean ambiguity", "Define scope", "Enable AOP"], "correct": 1 },
    { "id": 14, "question": "@Primary is used when:", "options": ["Only one bean exists", "Multiple beans exist", "No beans exist", "XML config only"], "correct": 1 },
    { "id": 15, "question": "Java-based configuration uses:", "options": ["XML only", "Annotations only", "Java classes", "JSP pages"], "correct": 2 },
    { "id": 16, "question": "AnnotationConfigApplicationContext is used to:", "options": ["Load XML context", "Load annotation-based config", "Load web context", "Load JDBC config"], "correct": 1 },
    { "id": 17, "question": "@Controller is used mainly for:", "options": ["DAO layer", "Service layer", "MVC controllers", "ORM mapping"], "correct": 2 },
    { "id": 18, "question": "@Component, @Service, @Repository are:", "options": ["Same behavior, different roles", "Different behavior always", "Only XML based", "Deprecated"], "correct": 0 },
    { "id": 19, "question": "Which annotation defines bean-producing method?", "options": ["@Component", "@Bean", "@Autowired", "@Scope"], "correct": 1 },
    { "id": 20, "question": "Which reduces XML configuration most?", "options": ["JDBC", "Annotations", "Scriptlets", "Native SQL"], "correct": 1 },

    { "id": 21, "question": "Which annotation enables component scanning in Java config?", "options": ["@Component", "@ComponentScan", "@Bean", "@Scope"], "correct": 1 },
    { "id": 22, "question": "Which injection avoids circular dependency issues most?", "options": ["Field injection", "Setter injection", "Constructor injection", "No injection"], "correct": 2 },
    { "id": 23, "question": "Which annotation indicates persistence exception translation?", "options": ["@Component", "@Service", "@Repository", "@Controller"], "correct": 2 },
    { "id": 24, "question": "Which ambiguity occurs without @Qualifier?", "options": ["No bean found", "Multiple beans of same type", "XML error", "Scope error"], "correct": 1 },
    { "id": 25, "question": "Which annotation marks configuration class?", "options": ["@Component", "@Bean", "@Configuration", "@Scope"], "correct": 2 },
    { "id": 26, "question": "Which annotation defines prototype scope?", "options": ["@Component", "@Scope(\"prototype\")", "@Primary", "@Qualifier"], "correct": 1 },
    { "id": 27, "question": "Which approach improves testability?", "options": ["Field injection", "Constructor injection", "Hard coding", "Scriptlets"], "correct": 1 },
    { "id": 28, "question": "Which context class loads Java config?", "options": ["ClassPathXmlApplicationContext", "FileSystemXmlApplicationContext", "AnnotationConfigApplicationContext", "WebApplicationContext"], "correct": 2 },
    { "id": 29, "question": "Which annotation resolves bean selection preference?", "options": ["@Qualifier", "@Primary", "@Scope", "@Bean"], "correct": 1 },
    { "id": 30, "question": "Which replaces definitions in XML?", "options": ["@Component only", "@Bean methods", "@Controller", "@Autowired"], "correct": 1 },

    { "id": 31, "question": "Which Spring feature scans classpath automatically?", "options": ["Component scanning", "JDBC", "ORM", "MVC"], "correct": 0 },
    { "id": 32, "question": "Which injection method is least recommended?", "options": ["Constructor", "Setter", "Field", "Java-based"], "correct": 2 },
    { "id": 33, "question": "Which annotation is logical specialization of @Component?", "options": ["@Bean", "@Autowired", "@Service", "@Scope"], "correct": 2 },
    { "id": 34, "question": "Which annotation defines bean lifecycle scope?", "options": ["@Bean", "@Component", "@Scope", "@Autowired"], "correct": 2 },
    { "id": 35, "question": "Which avoids tight coupling in config?", "options": ["Hard coding", "Java-based config", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 36, "question": "Which annotation enables automatic wiring by type?", "options": ["@Bean", "@Autowired", "@ComponentScan", "@Scope"], "correct": 1 },
    { "id": 37, "question": "Which is true about stereotype annotations?", "options": ["Different roles, same behavior", "Different behavior always", "Deprecated", "XML only"], "correct": 0 },
    { "id": 38, "question": "Which feature improves readability most?", "options": ["XML config", "Annotations", "JDBC", "Scriptlets"], "correct": 1 },
    { "id": 39, "question": "Which approach is recommended for large projects?", "options": ["XML-only config", "Annotation-based config", "Scriptlets", "Inline JDBC"], "correct": 1 },
    { "id": 40, "question": "Which annotation defines multiple beans via methods?", "options": ["@Component", "@Configuration", "@Controller", "@Service"], "correct": 1 },

    { "id": 41, "question": "Which misuse causes hidden dependencies?", "options": ["Constructor injection", "Field injection", "Java config", "@Bean methods"], "correct": 1 },
    { "id": 42, "question": "Which design improves refactoring safety?", "options": ["XML strings", "Annotations + Java config", "Scriptlets", "Hard coding"], "correct": 1 },
    { "id": 43, "question": "Which approach avoids XML duplication?", "options": ["XML-only", "Java-based configuration", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 44, "question": "Which annotation misuse causes ambiguity at runtime?", "options": ["Missing @ComponentScan", "Missing @Qualifier with multiple beans", "Missing @Scope", "Missing @Controller"], "correct": 1 },
    { "id": 45, "question": "Which approach best supports unit testing?", "options": ["Field injection", "Constructor injection", "Scriptlets", "Hard-coded beans"], "correct": 1 },
    { "id": 46, "question": "Which feature replaces XML scanning?", "options": ["@Component", "@ComponentScan", "@Bean", "@Autowired"], "correct": 1 },
    { "id": 47, "question": "Which annotation ensures bean preference without qualifiers?", "options": ["@Qualifier", "@Primary", "@Scope", "@Bean"], "correct": 1 },
    { "id": 48, "question": "Which design avoids tight coupling between config and implementation?", "options": ["Hard coding", "Dependency Injection", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 49, "question": "Which injection type is safest for immutability?", "options": ["Field injection", "Setter injection", "Constructor injection", "No injection"], "correct": 2 },
    { "id": 50, "question": "Which Spring Core feature enables modular design?", "options": ["JDBC", "Dependency Injection", "Scriptlets", "Inline SQL"], "correct": 1 },

    { "id": 51, "question": "Which approach best supports multiple implementations switching?", "options": ["Hard coding", "DI with qualifiers", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 52, "question": "Which annotation reduces XML verbosity most?", "options": ["@Autowired", "@ComponentScan", "@Configuration", "All of the above"], "correct": 3 },
    { "id": 53, "question": "Which misuse breaks clean architecture?", "options": ["Proper DI", "Annotations", "Hard-coded dependencies", "Java config"], "correct": 2 },
    { "id": 54, "question": "Which design helps maintain separation of concerns?", "options": ["Scriptlets", "Dependency Injection", "Inline SQL", "Hard coding"], "correct": 1 },
    { "id": 55, "question": "Which Spring feature ensures loose coupling?", "options": ["JDBC", "Dependency Injection", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 56, "question": "Which configuration style is easiest to debug?", "options": ["XML only", "Java-based configuration", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 57, "question": "Which injection approach avoids null dependencies?", "options": ["Field injection", "Setter injection", "Constructor injection", "No injection"], "correct": 2 },
    { "id": 58, "question": "Which approach improves compile-time checking?", "options": ["XML strings", "Java config + annotations", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 59, "question": "Which feature helps enforce required dependencies?", "options": ["Field injection", "Constructor injection", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 60, "question": "Which overall approach is best for modern Spring apps?", "options": ["XML-only config", "Annotation + Java config", "Scriptlets", "Hard coding"], "correct": 1 }
  ]
}
