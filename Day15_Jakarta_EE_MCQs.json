{
  "deck": "Day 15 – Spring MVC RESTful Web Services",
  "mcqs": [
    { "id": 1, "question": "REST stands for:", "options": ["Representational State Transfer", "Remote Execution Service Tool", "Resource State Transfer", "Runtime Execution Style"], "correct": 0 },
    { "id": 2, "question": "REST services are:", "options": ["Stateful", "Stateless", "Session-based", "UI dependent"], "correct": 1 },
    { "id": 3, "question": "Which annotation defines REST controller?", "options": ["@Controller", "@Service", "@RestController", "@Repository"], "correct": 2 },
    { "id": 4, "question": "@RestController is a combination of:", "options": ["@Controller + @RequestMapping", "@Controller + @ResponseBody", "@Service + @ResponseBody", "@Component + @ResponseBody"], "correct": 1 },
    { "id": 5, "question": "Which HTTP method retrieves data?", "options": ["POST", "PUT", "GET", "DELETE"], "correct": 2 },
    { "id": 6, "question": "Which HTTP method creates resource?", "options": ["GET", "POST", "PUT", "DELETE"], "correct": 1 },
    { "id": 7, "question": "Which HTTP method updates resource?", "options": ["GET", "POST", "PUT", "DELETE"], "correct": 2 },
    { "id": 8, "question": "Which HTTP method deletes resource?", "options": ["GET", "POST", "PUT", "DELETE"], "correct": 3 },
    { "id": 9, "question": "Which annotation reads request body?", "options": ["@RequestParam", "@PathVariable", "@RequestBody", "@ResponseBody"], "correct": 2 },
    { "id": 10, "question": "Which annotation controls HTTP response status?", "options": ["@ResponseBody", "@ResponseEntity", "@RequestParam", "@PathVariable"], "correct": 1 },

    { "id": 11, "question": "REST services usually return:", "options": ["JSP pages", "HTML", "JSON data", "XML only"], "correct": 2 },
    { "id": 12, "question": "Which annotation maps GET requests?", "options": ["@PostMapping", "@GetMapping", "@PutMapping", "@DeleteMapping"], "correct": 1 },
    { "id": 13, "question": "Which annotation maps POST requests?", "options": ["@GetMapping", "@PostMapping", "@PutMapping", "@DeleteMapping"], "correct": 1 },
    { "id": 14, "question": "REST follows which architecture style?", "options": ["Monolithic", "Client–Server", "Peer-to-peer", "Layered UI"], "correct": 1 },
    { "id": 15, "question": "Which annotation reads URL path value?", "options": ["@RequestBody", "@RequestParam", "@PathVariable", "@ResponseEntity"], "correct": 2 },
    { "id": 16, "question": "REST APIs are best suited for:", "options": ["View rendering", "Data exchange", "JSP pages", "UI styling"], "correct": 1 },
    { "id": 17, "question": "Which annotation returns object as response body?", "options": ["@ResponseBody", "@Controller", "@Service", "@Bean"], "correct": 0 },
    { "id": 18, "question": "Which protocol is commonly used in REST?", "options": ["FTP", "SMTP", "HTTP", "TCP"], "correct": 2 },
    { "id": 19, "question": "Which is NOT REST principle?", "options": ["Statelessness", "Client-server", "Session storage", "Resource-based"], "correct": 2 },
    { "id": 20, "question": "Which format is default in Spring REST?", "options": ["XML", "JSON", "CSV", "Text"], "correct": 1 },

    { "id": 21, "question": "Which annotation maps PUT request?", "options": ["@PutMapping", "@PostMapping", "@GetMapping", "@DeleteMapping"], "correct": 0 },
    { "id": 22, "question": "Which annotation maps DELETE request?", "options": ["@GetMapping", "@DeleteMapping", "@PutMapping", "@PostMapping"], "correct": 1 },
    { "id": 23, "question": "Which component converts JSON to Java object?", "options": ["Servlet", "Jackson", "JDBC", "JSP"], "correct": 1 },
    { "id": 24, "question": "Which annotation binds JSON to object?", "options": ["@RequestParam", "@RequestBody", "@PathVariable", "@ResponseBody"], "correct": 1 },
    { "id": 25, "question": "Which class represents HTTP response in Spring?", "options": ["Model", "HttpServletResponse", "ResponseEntity", "ViewResolver"], "correct": 2 },
    { "id": 26, "question": "Which HTTP status indicates resource created?", "options": ["200 OK", "201 Created", "400 Bad Request", "500 Server Error"], "correct": 1 },
    { "id": 27, "question": "Which REST design uses nouns in URL?", "options": ["/getUser", "/createUser", "/users", "/doUser"], "correct": 2 },
    { "id": 28, "question": "Which annotation combines @Controller and @ResponseBody?", "options": ["@Controller", "@Service", "@RestController", "@Component"], "correct": 2 },
    { "id": 29, "question": "Which HTTP method is idempotent?", "options": ["POST", "PUT", "PATCH", "CONNECT"], "correct": 1 },
    { "id": 30, "question": "Which REST constraint improves scalability?", "options": ["Stateful", "Stateless", "Session-based", "UI based"], "correct": 1 },

    { "id": 31, "question": "Which annotation reads optional query param?", "options": ["@RequestParam(required=false)", "@RequestBody", "@PathVariable", "@ResponseEntity"], "correct": 0 },
    { "id": 32, "question": "Which REST endpoint is best designed?", "options": ["/addEmployee", "/deleteEmployee", "/employees", "/doWork"], "correct": 2 },
    { "id": 33, "question": "Which HTTP method should NOT change server state?", "options": ["GET", "POST", "PUT", "DELETE"], "correct": 0 },
    { "id": 34, "question": "Which annotation sets response status explicitly?", "options": ["@ResponseBody", "@ResponseEntity", "@RequestParam", "@PathVariable"], "correct": 1 },
    { "id": 35, "question": "Which REST feature avoids server-side session storage?", "options": ["Client-server", "Statelessness", "Caching", "Layered system"], "correct": 1 },
    { "id": 36, "question": "Which method returns HTTP status + body together?", "options": ["Model", "ResponseEntity", "ViewResolver", "DispatcherServlet"], "correct": 1 },
    { "id": 37, "question": "Which annotation handles REST data output?", "options": ["@ResponseBody", "@Controller", "@Service", "@Bean"], "correct": 0 },
    { "id": 38, "question": "Which is correct REST URL design?", "options": ["/getAllUsers", "/users/all", "/users", "/doUsers"], "correct": 2 },
    { "id": 39, "question": "Which REST style uses HTTP verbs instead of action names?", "options": ["SOAP", "REST", "RPC", "JDBC"], "correct": 1 },
    { "id": 40, "question": "Which HTTP status indicates success?", "options": ["404", "500", "200", "403"], "correct": 2 },

    { "id": 41, "question": "Which misuse violates REST principles?", "options": ["Stateless services", "Resource-based URLs", "Using sessions on server", "Using HTTP verbs"], "correct": 2 },
    { "id": 42, "question": "Why @RestController is preferred over @Controller in REST?", "options": ["View rendering", "Automatic JSON response", "JSP support", "Session handling"], "correct": 1 },
    { "id": 43, "question": "Which design improves API evolvability?", "options": ["Action-based URLs", "Resource-based URLs", "Hard-coded logic", "Scriptlets"], "correct": 1 },
    { "id": 44, "question": "Which HTTP method is safest for read-only operations?", "options": ["POST", "PUT", "GET", "DELETE"], "correct": 2 },
    { "id": 45, "question": "Which REST constraint improves caching?", "options": ["Statelessness", "Uniform interface", "Layered system", "Client-server"], "correct": 1 },
    { "id": 46, "question": "Which misuse makes REST APIs hard to maintain?", "options": ["Proper status codes", "Action verbs in URLs", "JSON responses", "HTTP methods"], "correct": 1 },
    { "id": 47, "question": "Which approach best supports front-end frameworks?", "options": ["JSP MVC", "REST APIs", "Scriptlets", "Inline JDBC"], "correct": 1 },
    { "id": 48, "question": "Which REST design avoids tight coupling?", "options": ["Stateful services", "Stateless services", "Session storage", "Server memory"], "correct": 1 },
    { "id": 49, "question": "Which HTTP status should be returned on delete success?", "options": ["200 or 204", "500", "404", "301"], "correct": 0 },
    { "id": 50, "question": "Which approach improves REST API security indirectly?", "options": ["Session storage", "Stateless design", "Scriptlets", "Hard coding"], "correct": 1 },

    { "id": 51, "question": "Which REST feature improves horizontal scalability?", "options": ["Stateful sessions", "Statelessness", "Hard-coded IPs", "Server memory"], "correct": 1 },
    { "id": 52, "question": "Which annotation ensures JSON serialization automatically?", "options": ["@Controller", "@RestController", "@Service", "@Bean"], "correct": 1 },
    { "id": 53, "question": "Which design helps API consumers most?", "options": ["Unclear URLs", "Proper HTTP methods & status codes", "Scriptlets", "Inline SQL"], "correct": 1 },
    { "id": 54, "question": "Which misuse breaks idempotency?", "options": ["PUT updating resource", "POST creating resource", "GET modifying data", "DELETE removing resource"], "correct": 2 },
    { "id": 55, "question": "Which REST principle helps loose coupling?", "options": ["Statelessness", "Uniform interface", "Both A and B", "Session handling"], "correct": 2 },
    { "id": 56, "question": "Which approach best supports microservices later?", "options": ["JSP MVC", "REST APIs", "Scriptlets", "Inline JDBC"], "correct": 1 },
    { "id": 57, "question": "Which misuse causes unclear API semantics?", "options": ["Proper nouns in URLs", "Action verbs in URLs", "Proper HTTP verbs", "JSON responses"], "correct": 1 },
    { "id": 58, "question": "Which REST feature allows independent client evolution?", "options": ["Statelessness", "Uniform interface", "Client-server separation", "Caching"], "correct": 2 },
    { "id": 59, "question": "Which annotation is best for REST controllers?", "options": ["@Controller", "@Service", "@RestController", "@Component"], "correct": 2 },
    { "id": 60, "question": "Which overall design is best for APIs?", "options": ["Action-based URLs", "RESTful resource-based APIs", "Session-based services", "Scriptlets"], "correct": 1 }
  ]
}
